树莓派A1 用 ST7735 128*128屏 当系统的显示屏 创建用户空间SPI framebuffer驱动
我们使用SPI0引脚连接：
SCLK -> GPIO11 (BCM)
MOSI -> GPIO10 (BCM)
DC -> GPIO25 (BCM) (数据/命令选择)
CS -> GPIO8 (BCM) (片选，低电平有效)
RST -> GPIO27 (BCM) (复位，低电平复位)
BL -> GPIO24 (BCM) (背光，高电平点亮)

1. 安装必要的依赖
bash
# 安装bcm2835库
apt-get update
apt-get install -y libbcm2835-dev build-essential

# 如果bcm2835库不可用，可以使用wiringPi或pigpio   如果上面的安装正常，这里不用安装。
apt-get install -y wiringpi pigpio

# 安装framebuffer工具
apt-get install -y fbset fbterm con2fbmap




2. 创建用户空间framebuffer驱动
创建 st7735_fb.c：

####=========    st7735_fb.c  begin =========####

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/fb.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <bcm2835.h>
#include <time.h>

// 屏幕尺寸
#define WIDTH 128
#define HEIGHT 128
#define BPP 16  // RGB565

// 颜色定义 (RGB565)
#define BLACK     0x0000
#define WHITE     0xFFFF
#define RED       0xF800
#define GREEN     0x07E0
#define BLUE      0x001F

// 引脚定义
#define DC_PIN      RPI_V2_GPIO_P1_22  // GPIO25
#define RST_PIN     RPI_V2_GPIO_P1_13  // GPIO27
#define BL_PIN      RPI_V2_GPIO_P1_18  // GPIO24
#define CS_PIN      RPI_V2_GPIO_P1_24  // GPIO8

// 全局变量
static int fb_fd = -1;
static struct fb_var_screeninfo vinfo;
static struct fb_fix_screeninfo finfo;
static char *fb_buffer = NULL;
static long screensize = 0;

// ST7735命令
#define ST7735_NOP     0x00
#define ST7735_SWRESET 0x01
#define ST7735_SLPOUT  0x11
#define ST7735_DISPON  0x29
#define ST7735_CASET   0x2A
#define ST7735_RASET   0x2B
#define ST7735_RAMWR   0x2C
#define ST7735_COLMOD  0x3A
#define ST7735_MADCTL  0x36

// 写命令到ST7735
void write_command(uint8_t cmd) {
    bcm2835_gpio_write(DC_PIN, LOW);
    bcm2835_spi_transfer(cmd);
}

// 写数据到ST7735
void write_data(uint8_t data) {
    bcm2835_gpio_write(DC_PIN, HIGH);
    bcm2835_spi_transfer(data);
}

// 写16位数据到ST7735
void write_data16(uint16_t data) {
    bcm2835_gpio_write(DC_PIN, HIGH);
    bcm2835_spi_transfer(data >> 8);
    bcm2835_spi_transfer(data & 0xFF);
}

// 设置显示窗口
void set_address_window(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
    write_command(ST7735_CASET);
    write_data(0x00);
    write_data(x0 + 2);  // 列起始偏移
    write_data(0x00);
    write_data(x1 + 2);  // 列结束
    
    write_command(ST7735_RASET);
    write_data(0x00);
    write_data(y0 + 3);  // 行起始偏移
    write_data(0x00);
    write_data(y1 + 3);  // 行结束
    
    write_command(ST7735_RAMWR);
}

// 初始化ST7735
void st7735_init(void) {
    printf("Initializing ST7735...\n");
    
    // 初始化GPIO
    bcm2835_gpio_fsel(DC_PIN, BCM2835_GPIO_FSEL_OUTP);
    bcm2835_gpio_fsel(RST_PIN, BCM2835_GPIO_FSEL_OUTP);
    bcm2835_gpio_fsel(BL_PIN, BCM2835_GPIO_FSEL_OUTP);
    
    // 初始化SPI
    bcm2835_spi_begin();
    bcm2835_spi_setBitOrder(BCM2835_SPI_BIT_ORDER_MSBFIRST);
    bcm2835_spi_setDataMode(BCM2835_SPI_MODE0);
    bcm2835_spi_setClockDivider(BCM2835_SPI_CLOCK_DIVIDER_64);
    bcm2835_spi_chipSelect(BCM2835_SPI_CS0);
    bcm2835_spi_setChipSelectPolarity(BCM2835_SPI_CS0, LOW);
    
    // 硬件复位
    bcm2835_gpio_write(RST_PIN, HIGH);
    usleep(100000);
    bcm2835_gpio_write(RST_PIN, LOW);
    usleep(100000);
    bcm2835_gpio_write(RST_PIN, HIGH);
    usleep(100000);
    
    // 背光开启
    bcm2835_gpio_write(BL_PIN, HIGH);
    
    // 软件复位
    write_command(ST7735_SWRESET);
    usleep(150000);
    
    // 退出睡眠模式
    write_command(ST7735_SLPOUT);
    usleep(150000);
    
    // 颜色模式：RGB565
    write_command(ST7735_COLMOD);
    write_data(0x05);
    
    // 内存访问控制
    write_command(ST7735_MADCTL);
    write_data(0xC0);  // 旋转设置
    
    // 显示开启
    write_command(ST7735_DISPON);
    usleep(100000);
    
    printf("ST7735 initialized.\n");
}

// 将framebuffer内容刷新到屏幕
void flush_framebuffer() {
    set_address_window(0, 0, WIDTH-1, HEIGHT-1);
    
    uint16_t *fb_ptr = (uint16_t*)fb_buffer;
    
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            uint16_t color = fb_ptr[y * WIDTH + x];
            write_data16(color);
        }
    }
}

// 创建虚拟framebuffer
int create_framebuffer() {
    // 创建一个虚拟framebuffer设备
    fb_fd = open("/dev/fb0", O_RDWR);
    if (fb_fd < 0) {
        // 尝试创建新的framebuffer
        system("mknod /dev/fb1 c 29 1");
        fb_fd = open("/dev/fb1", O_RDWR | O_CREAT, 0666);
        if (fb_fd < 0) {
            perror("Failed to open framebuffer");
            return -1;
        }
    }
    
    // 获取framebuffer信息
    if (ioctl(fb_fd, FBIOGET_FSCREENINFO, &finfo)) {
        perror("Error reading fixed information");
        return -2;
    }
    
    if (ioctl(fb_fd, FBIOGET_VSCREENINFO, &vinfo)) {
        perror("Error reading variable information");
        return -3;
    }
    
    // 设置framebuffer参数
    vinfo.xres = WIDTH;
    vinfo.yres = HEIGHT;
    vinfo.xres_virtual = WIDTH;
    vinfo.yres_virtual = HEIGHT;
    vinfo.bits_per_pixel = BPP;
    vinfo.red.offset = 11; vinfo.red.length = 5;
    vinfo.green.offset = 5; vinfo.green.length = 6;
    vinfo.blue.offset = 0; vinfo.blue.length = 5;
    
    if (ioctl(fb_fd, FBIOPUT_VSCREENINFO, &vinfo)) {
        perror("Error setting variable information");
        return -4;
    }
    
    // 重新获取更新后的信息
    ioctl(fb_fd, FBIOGET_VSCREENINFO, &vinfo);
    
    // 计算缓冲区大小
    screensize = vinfo.xres * vinfo.yres * vinfo.bits_per_pixel / 8;
    
    // 映射framebuffer到内存
    fb_buffer = (char*)mmap(0, screensize, PROT_READ | PROT_WRITE, 
                           MAP_SHARED, fb_fd, 0);
    
    if ((long)fb_buffer == -1) {
        perror("Failed to mmap framebuffer");
        return -5;
    }
    
    printf("Framebuffer created: %dx%d, %d bpp\n", 
           vinfo.xres, vinfo.yres, vinfo.bits_per_pixel);
    
    return 0;
}

// 清理函数
void cleanup() {
    if (fb_buffer) munmap(fb_buffer, screensize);
    if (fb_fd >= 0) close(fb_fd);
    bcm2835_gpio_write(BL_PIN, LOW);
    bcm2835_spi_end();
    bcm2835_close();
}

// 主函数
int main(int argc, char *argv[]) {
    printf("ST7735 User-space Framebuffer Driver\n");
    
    // 初始化bcm2835
    if (!bcm2835_init()) {
        printf("Failed to initialize bcm2835\n");
        return 1;
    }
    
    // 初始化ST7735
    st7735_init();
    
    // 创建framebuffer
    if (create_framebuffer() < 0) {
        printf("Failed to create framebuffer\n");
        cleanup();
        return 1;
    }
    
    // 清屏
    memset(fb_buffer, 0, screensize);
    flush_framebuffer();
    
    printf("Driver ready. Press Ctrl+C to exit.\n");
    
    // 主循环：定期刷新framebuffer到屏幕
    while (1) {
        flush_framebuffer();
        usleep(16666);  // 约60Hz刷新率
    }
    
    cleanup();
    return 0;
}

####=========    st7735_fb.c  end =========####





####=========    st7735_fb.c  优化版 begin =========####

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/fb.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <bcm2835.h>

// 屏幕尺寸 (128x160)
#define WIDTH 128
#define HEIGHT 160
#define BPP 16  // RGB565

// 颜色定义 (RGB565)
#define BLACK     0x0000
#define WHITE     0xFFFF
#define RED       0xF800
#define GREEN     0x07E0
#define BLUE      0x001F
#define YELLOW    0xFFE0
#define CYAN      0x07FF
#define MAGENTA   0xF81F
#define GRAY      0x8410
#define LIGHT_GRAY 0xC618

// 引脚定义
#define DC_PIN      RPI_V2_GPIO_P1_22  // GPIO25
#define RST_PIN     RPI_V2_GPIO_P1_13  // GPIO27
#define BL_PIN      RPI_V2_GPIO_P1_18  // GPIO24
#define CS_PIN      RPI_V2_GPIO_P1_24  // GPIO8

// ST7735显示窗口偏移量 - 根据实际屏幕调整
#define X_OFFSET 2   // 列偏移
#define Y_OFFSET 3   // 行偏移

// 全局变量
static int fb_fd = -1;
static struct fb_var_screeninfo vinfo;
static struct fb_fix_screeninfo finfo;
static char *fb_buffer = NULL;
static long screensize = 0;

// ST7735命令
#define ST7735_NOP     0x00
#define ST7735_SWRESET 0x01
#define ST7735_SLPOUT  0x11
#define ST7735_DISPON  0x29
#define ST7735_CASET   0x2A
#define ST7735_RASET   0x2B
#define ST7735_RAMWR   0x2C
#define ST7735_COLMOD  0x3A
#define ST7735_MADCTL  0x36

// 6x8 ASCII字库
static const uint8_t font6x8[96][6] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 空格 (32)
    {0x00, 0x00, 0x5F, 0x00, 0x00, 0x00}, // ! (33)
    {0x00, 0x03, 0x00, 0x03, 0x00, 0x00}, // " (34)
    {0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00}, // # (35)
    {0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00}, // $ (36)
    {0x23, 0x13, 0x08, 0x64, 0x62, 0x00}, // % (37)
    {0x36, 0x49, 0x55, 0x22, 0x50, 0x00}, // & (38)
    {0x00, 0x05, 0x03, 0x00, 0x00, 0x00}, // ' (39)
    {0x00, 0x1C, 0x22, 0x41, 0x00, 0x00}, // ( (40)
    {0x00, 0x41, 0x22, 0x1C, 0x00, 0x00}, // ) (41)
    {0x14, 0x08, 0x3E, 0x08, 0x14, 0x00}, // * (42)
    {0x08, 0x08, 0x3E, 0x08, 0x08, 0x00}, // + (43)
    {0x00, 0x50, 0x30, 0x00, 0x00, 0x00}, // , (44)
    {0x08, 0x08, 0x08, 0x08, 0x08, 0x00}, // - (45)
    {0x00, 0x60, 0x60, 0x00, 0x00, 0x00}, // . (46)
    {0x20, 0x10, 0x08, 0x04, 0x02, 0x00}, // / (47)
    {0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00}, // 0 (48)
    {0x00, 0x42, 0x7F, 0x40, 0x00, 0x00}, // 1 (49)
    {0x42, 0x61, 0x51, 0x49, 0x46, 0x00}, // 2 (50)
    {0x21, 0x41, 0x45, 0x4B, 0x31, 0x00}, // 3 (51)
    {0x18, 0x14, 0x12, 0x7F, 0x10, 0x00}, // 4 (52)
    {0x27, 0x45, 0x45, 0x45, 0x39, 0x00}, // 5 (53)
    {0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00}, // 6 (54)
    {0x01, 0x71, 0x09, 0x05, 0x03, 0x00}, // 7 (55)
    {0x36, 0x49, 0x49, 0x49, 0x36, 0x00}, // 8 (56)
    {0x06, 0x49, 0x49, 0x29, 0x1E, 0x00}, // 9 (57)
    {0x00, 0x36, 0x36, 0x00, 0x00, 0x00}, // : (58)
    {0x00, 0x56, 0x36, 0x00, 0x00, 0x00}, // ; (59)
    {0x08, 0x14, 0x22, 0x41, 0x00, 0x00}, // < (60)
    {0x14, 0x14, 0x14, 0x14, 0x14, 0x00}, // = (61)
    {0x00, 0x41, 0x22, 0x14, 0x08, 0x00}, // > (62)
    {0x02, 0x01, 0x51, 0x09, 0x06, 0x00}, // ? (63)
    {0x32, 0x49, 0x79, 0x41, 0x3E, 0x00}, // @ (64)
    {0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00}, // A (65)
    {0x7F, 0x49, 0x49, 0x49, 0x36, 0x00}, // B (66)
    {0x3E, 0x41, 0x41, 0x41, 0x22, 0x00}, // C (67)
    {0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00}, // D (68)
    {0x7F, 0x49, 0x49, 0x49, 0x41, 0x00}, // E (69)
    {0x7F, 0x09, 0x09, 0x09, 0x01, 0x00}, // F (70)
    {0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00}, // G (71)
    {0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00}, // H (72)
    {0x00, 0x41, 0x7F, 0x41, 0x00, 0x00}, // I (73)
    {0x20, 0x40, 0x41, 0x3F, 0x01, 0x00}, // J (74)
    {0x7F, 0x08, 0x14, 0x22, 0x41, 0x00}, // K (75)
    {0x7F, 0x40, 0x40, 0x40, 0x40, 0x00}, // L (76)
    {0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00}, // M (77)
    {0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00}, // N (78)
    {0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00}, // O (79)
    {0x7F, 0x09, 0x09, 0x09, 0x06, 0x00}, // P (80)
    {0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00}, // Q (81)
    {0x7F, 0x09, 0x19, 0x29, 0x46, 0x00}, // R (82)
    {0x46, 0x49, 0x49, 0x49, 0x31, 0x00}, // S (83)
    {0x01, 0x01, 0x7F, 0x01, 0x01, 0x00}, // T (84)
    {0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00}, // U (85)
    {0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00}, // V (86)
    {0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00}, // W (87)
    {0x63, 0x14, 0x08, 0x14, 0x63, 0x00}, // X (88)
    {0x07, 0x08, 0x70, 0x08, 0x07, 0x00}, // Y (89)
    {0x61, 0x51, 0x49, 0x45, 0x43, 0x00}, // Z (90)
    {0x00, 0x7F, 0x41, 0x41, 0x00, 0x00}, // [ (91)
    {0x02, 0x04, 0x08, 0x10, 0x20, 0x00}, // \ (92)
    {0x00, 0x41, 0x41, 0x7F, 0x00, 0x00}, // ] (93)
    {0x04, 0x02, 0x01, 0x02, 0x04, 0x00}, // ^ (94)
    {0x40, 0x40, 0x40, 0x40, 0x40, 0x00}, // _ (95)
    {0x00, 0x01, 0x02, 0x04, 0x00, 0x00}, // ` (96)
    {0x20, 0x54, 0x54, 0x54, 0x78, 0x00}, // a (97)
    {0x7F, 0x48, 0x44, 0x44, 0x38, 0x00}, // b (98)
    {0x38, 0x44, 0x44, 0x44, 0x20, 0x00}, // c (99)
    {0x38, 0x44, 0x44, 0x48, 0x7F, 0x00}, // d (100)
    {0x38, 0x54, 0x54, 0x54, 0x18, 0x00}, // e (101)
    {0x08, 0x7E, 0x09, 0x01, 0x02, 0x00}, // f (102)
    {0x0C, 0x52, 0x52, 0x52, 0x3E, 0x00}, // g (103)
    {0x7F, 0x08, 0x04, 0x04, 0x78, 0x00}, // h (104)
    {0x00, 0x44, 0x7D, 0x40, 0x00, 0x00}, // i (105)
    {0x20, 0x40, 0x44, 0x3D, 0x00, 0x00}, // j (106)
    {0x7F, 0x10, 0x28, 0x44, 0x00, 0x00}, // k (107)
    {0x00, 0x41, 0x7F, 0x40, 0x00, 0x00}, // l (108)
    {0x7C, 0x04, 0x18, 0x04, 0x78, 0x00}, // m (109)
    {0x7C, 0x08, 0x04, 0x04, 0x78, 0x00}, // n (110)
    {0x38, 0x44, 0x44, 0x44, 0x38, 0x00}, // o (111)
    {0x7C, 0x14, 0x14, 0x14, 0x08, 0x00}, // p (112)
    {0x08, 0x14, 0x14, 0x18, 0x7C, 0x00}, // q (113)
    {0x7C, 0x08, 0x04, 0x04, 0x08, 0x00}, // r (114)
    {0x48, 0x54, 0x54, 0x54, 0x20, 0x00}, // s (115)
    {0x04, 0x3F, 0x44, 0x40, 0x20, 0x00}, // t (116)
    {0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00}, // u (117)
    {0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00}, // v (118)
    {0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00}, // w (119)
    {0x44, 0x28, 0x10, 0x28, 0x44, 0x00}, // x (120)
    {0x0C, 0x50, 0x50, 0x50, 0x3C, 0x00}, // y (121)
    {0x44, 0x64, 0x54, 0x4C, 0x44, 0x00}, // z (122)
    {0x00, 0x08, 0x36, 0x41, 0x00, 0x00}, // { (123)
    {0x00, 0x00, 0x7F, 0x00, 0x00, 0x00}, // | (124)
    {0x00, 0x41, 0x36, 0x08, 0x00, 0x00}, // } (125)
    {0x08, 0x04, 0x08, 0x10, 0x08, 0x00}, // ~ (126)
    {0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x00}  //  (127)
};

// 写命令到ST7735
void write_command(uint8_t cmd) {
    bcm2835_gpio_write(DC_PIN, LOW);
    bcm2835_spi_transfer(cmd);
}

// 写数据到ST7735
void write_data(uint8_t data) {
    bcm2835_gpio_write(DC_PIN, HIGH);
    bcm2835_spi_transfer(data);
}

// 写16位数据到ST7735
void write_data16(uint16_t data) {
    bcm2835_gpio_write(DC_PIN, HIGH);
    bcm2835_spi_transfer(data >> 8);
    bcm2835_spi_transfer(data & 0xFF);
}

// 设置显示窗口 - 使用宏定义的偏移量
void set_address_window(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
    write_command(ST7735_CASET);
    write_data(0x00);
    write_data(x0 + X_OFFSET);
    write_data(0x00);
    write_data(x1 + X_OFFSET);
    
    write_command(ST7735_RASET);
    write_data(0x00);
    write_data(y0 + Y_OFFSET);
    write_data(0x00);
    write_data(y1 + Y_OFFSET);
    
    write_command(ST7735_RAMWR);
}

// 初始化ST7735
void st7735_init(void) {
    // 初始化GPIO
    bcm2835_gpio_fsel(DC_PIN, BCM2835_GPIO_FSEL_OUTP);
    bcm2835_gpio_fsel(RST_PIN, BCM2835_GPIO_FSEL_OUTP);
    bcm2835_gpio_fsel(BL_PIN, BCM2835_GPIO_FSEL_OUTP);
    
    // 初始化SPI
    bcm2835_spi_begin();
    bcm2835_spi_setBitOrder(BCM2835_SPI_BIT_ORDER_MSBFIRST);
    bcm2835_spi_setDataMode(BCM2835_SPI_MODE0);
    bcm2835_spi_setClockDivider(BCM2835_SPI_CLOCK_DIVIDER_64);
    bcm2835_spi_chipSelect(BCM2835_SPI_CS0);
    bcm2835_spi_setChipSelectPolarity(BCM2835_SPI_CS0, LOW);
    
    // 硬件复位
    bcm2835_gpio_write(RST_PIN, HIGH);
    usleep(100000);
    bcm2835_gpio_write(RST_PIN, LOW);
    usleep(100000);
    bcm2835_gpio_write(RST_PIN, HIGH);
    usleep(100000);
    
    // 背光开启
    bcm2835_gpio_write(BL_PIN, HIGH);
    
    // 软件复位
    write_command(ST7735_SWRESET);
    usleep(150000);
    
    // 退出睡眠模式
    write_command(ST7735_SLPOUT);
    usleep(150000);
    
    // 颜色模式：RGB565
    write_command(ST7735_COLMOD);
    write_data(0x05);
    
    // 内存访问控制
    write_command(ST7735_MADCTL);
    write_data(0xC8);
    
    // 显示开启
    write_command(ST7735_DISPON);
    usleep(100000);
}

// 将framebuffer内容刷新到屏幕
void flush_framebuffer() {
    set_address_window(0, 0, WIDTH-1, HEIGHT-1);
    
    uint16_t *fb_ptr = (uint16_t*)fb_buffer;
    
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            uint16_t color = fb_ptr[y * WIDTH + x];
            write_data16(color);
        }
    }
}

// 绘制像素点
void draw_pixel(int x, int y, uint16_t color) {
    if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) return;
    
    uint16_t *fb_ptr = (uint16_t*)fb_buffer;
    fb_ptr[y * WIDTH + x] = color;
}

// 绘制6x8字体字符
void draw_char_6x8(int x, int y, char c, uint16_t color, uint16_t bg_color) {
    if (c < 32 || c > 127) c = ' ';
    int index = c - 32;
    
    for (int i = 0; i < 6; i++) {
        uint8_t line = font6x8[index][i];
        for (int j = 0; j < 8; j++) {
            int px = x + i;
            int py = y + j;
            if (px >= 0 && px < WIDTH && py >= 0 && py < HEIGHT) {
                if (line & (1 << j)) {
                    draw_pixel(px, py, color);
                } else {
                    draw_pixel(px, py, bg_color);
                }
            }
        }
    }
}

// 绘制字符串
void draw_string_6x8(int x, int y, const char *str, uint16_t color, uint16_t bg_color) {
    int start_x = x;
    while (*str) {
        if (*str == '\n') {
            y += 9;
            x = start_x;
        } else {
            draw_char_6x8(x, y, *str, color, bg_color);
            x += 7;  // 6像素宽度 + 1像素间距
        }
        str++;
    }
}

// 清屏 - 确保完全清屏
void clear_screen(uint16_t color) {
    uint16_t *fb_ptr = (uint16_t*)fb_buffer;
    for (int i = 0; i < WIDTH * HEIGHT; i++) {
        fb_ptr[i] = color;
    }
}

// 绘制矩形
void draw_rect(int x, int y, int w, int h, uint16_t color) {
    for (int i = 0; i < w; i++) {
        for (int j = 0; j < h; j++) {
            int px = x + i;
            int py = y + j;
            if (px >= 0 && px < WIDTH && py >= 0 && py < HEIGHT) {
                draw_pixel(px, py, color);
            }
        }
    }
}

// 绘制空心矩形
void draw_rect_outline(int x, int y, int w, int h, uint16_t color) {
    // 上边
    for (int i = 0; i < w; i++) {
        int px = x + i;
        if (px >= 0 && px < WIDTH && y >= 0 && y < HEIGHT) {
            draw_pixel(px, y, color);
        }
    }
    // 下边
    for (int i = 0; i < w; i++) {
        int px = x + i;
        int py = y + h - 1;
        if (px >= 0 && px < WIDTH && py >= 0 && py < HEIGHT) {
            draw_pixel(px, py, color);
        }
    }
    // 左边
    for (int j = 1; j < h - 1; j++) {
        int py = y + j;
        if (x >= 0 && x < WIDTH && py >= 0 && py < HEIGHT) {
            draw_pixel(x, py, color);
        }
    }
    // 右边
    for (int j = 1; j < h - 1; j++) {
        int px = x + w - 1;
        int py = y + j;
        if (px >= 0 && px < WIDTH && py >= 0 && py < HEIGHT) {
            draw_pixel(px, py, color);
        }
    }
}

// 创建虚拟framebuffer
int create_framebuffer() {
    fb_fd = open("/dev/fb0", O_RDWR);
    if (fb_fd < 0) {
        system("mknod /dev/fb1 c 29 1 2>/dev/null");
        fb_fd = open("/dev/fb1", O_RDWR | O_CREAT, 0666);
        if (fb_fd < 0) {
            perror("Failed to open framebuffer");
            return -1;
        }
    }
    
    // 获取framebuffer信息
    if (ioctl(fb_fd, FBIOGET_FSCREENINFO, &finfo)) {
        perror("Error reading fixed information");
        return -2;
    }
    
    if (ioctl(fb_fd, FBIOGET_VSCREENINFO, &vinfo)) {
        perror("Error reading variable information");
        return -3;
    }
    
    // 设置framebuffer参数
    vinfo.xres = WIDTH;
    vinfo.yres = HEIGHT;
    vinfo.xres_virtual = WIDTH;
    vinfo.yres_virtual = HEIGHT;
    vinfo.bits_per_pixel = BPP;
    vinfo.red.offset = 11; vinfo.red.length = 5;
    vinfo.green.offset = 5; vinfo.green.length = 6;
    vinfo.blue.offset = 0; vinfo.blue.length = 5;
    
    if (ioctl(fb_fd, FBIOPUT_VSCREENINFO, &vinfo)) {
        perror("Error setting variable information");
        return -4;
    }
    
    // 重新获取更新后的信息
    ioctl(fb_fd, FBIOGET_VSCREENINFO, &vinfo);
    
    // 计算缓冲区大小
    screensize = vinfo.xres * vinfo.yres * vinfo.bits_per_pixel / 8;
    
    // 映射framebuffer到内存
    fb_buffer = (char*)mmap(0, screensize, PROT_READ | PROT_WRITE, 
                           MAP_SHARED, fb_fd, 0);
    
    if ((long)fb_buffer == -1) {
        perror("Failed to mmap framebuffer");
        return -5;
    }
    
    return 0;
}

// 清理函数
void cleanup() {
    if (fb_buffer) munmap(fb_buffer, screensize);
    if (fb_fd >= 0) close(fb_fd);
    bcm2835_gpio_write(BL_PIN, LOW);
    bcm2835_spi_end();
    bcm2835_close();
}

// 主函数
int main(int argc, char *argv[]) {
    // 设置控制台字体大小（仅对Raspberry Pi控制台有效）
    system("setfont Lat15-Terminus16x8 2>/dev/null");
    
    // 初始化bcm2835
    if (!bcm2835_init()) {
        return 1;
    }
    
    // 初始化ST7735
    st7735_init();
    
    // 创建framebuffer
    if (create_framebuffer() < 0) {
        cleanup();
        return 1;
    }
    
    // 清屏为黑色
    clear_screen(BLACK);
    
    // 绘制测试图案
    // 1. 绘制边框检查边缘
    draw_rect_outline(0, 0, WIDTH, HEIGHT, WHITE);
    
    // 2. 在四个角落绘制彩色方块
    draw_rect(2, 2, 4, 4, RED);                    // 左上角
    draw_rect(WIDTH-6, 2, 4, 4, GREEN);           // 右上角
    draw_rect(2, HEIGHT-6, 4, 4, BLUE);           // 左下角
    draw_rect(WIDTH-6, HEIGHT-6, 4, 4, YELLOW);   // 右下角
    
    // 3. 显示屏幕信息
    draw_string_6x8(10, 20, "ST7735 128x160", CYAN, BLACK);
    draw_string_6x8(10, 35, "Offset Test", MAGENTA, BLACK);
    
    // 4. 绘制网格线检查像素对齐
    for (int x = 0; x < WIDTH; x += 10) {
        for (int y = 0; y < HEIGHT; y++) {
            if (y % 20 == 0) {
                draw_pixel(x, y, GRAY);
            }
        }
    }
    
    // 5. 在屏幕中央显示颜色条
    for (int i = 0; i < WIDTH; i++) {
        int color_index = (i * 6) / WIDTH;
        uint16_t color;
        switch (color_index) {
            case 0: color = RED; break;
            case 1: color = GREEN; break;
            case 2: color = BLUE; break;
            case 3: color = YELLOW; break;
            case 4: color = CYAN; break;
            case 5: color = MAGENTA; break;
            default: color = WHITE;
        }
        for (int j = 0; j < 5; j++) {
            draw_pixel(i, 70 + j, color);
        }
    }
    
    // 刷新到屏幕
    flush_framebuffer();
    
    // 主循环：定期刷新framebuffer到屏幕
    while (1) {
        flush_framebuffer();
        usleep(16666);  // 约60Hz刷新率
    }
    
    cleanup();
    return 0;
}

####=========    st7735_fb.c  优化版 end =========####





3. 编译驱动程序

cd /root/go_run/st7735
gcc -o st7735_fb st7735_fb.c -lbcm2835 -lm

4. 创建systemd服务
创建 /etc/systemd/system/st7735-fb.service：

####=========    st7735-fb.service  begin =========####

[Unit]
Description=ST7735 User-space Framebuffer Driver
After=multi-user.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=/root/go_run/st7735/st7735_fb
WorkingDirectory=/root/go_run/st7735
Restart=always
RestartSec=5
User=root
Environment=DISPLAY=:0

[Install]
WantedBy=multi-user.target

####=========    st7735-fb.service  end =========####


####=========  如果想更快的显示启动过程，可用这个 =========####
[Unit]
Description=ST7735 User-space Framebuffer Driver
# 系统初始化完成就启动
After=sysinit.target
# 确保必要的设备可用
# 确保SPI/I2C设备可用（根据实际硬件）
Requires=dev-spidev0.0.device

DefaultDependencies=no  # 跳过默认依赖，可以更早启动

[Service]
Type=simple
ExecStart=/root/go_run/st7735/st7735_fb
WorkingDirectory=/root/go_run/st7735
Restart=always
RestartSec=5
User=root

[Install]
WantedBy=sysinit.target

####==================####



5. 创建控制台重定向脚本
创建 /usr/local/bin/console-to-st7735.sh：

####=========    console-to-st7735.sh  begin =========####

#!/bin/bash

# 等待驱动程序启动
sleep 5

# 如果/dev/fb1不存在，创建一个
if [ ! -e "/dev/fb1" ]; then
    mknod /dev/fb1 c 29 1
    chmod 666 /dev/fb1
fi

# 设置控制台字体（小字体适合128x128分辨率）
if [ -f "/usr/share/consolefonts/Uni2-Terminus12x6.psf.gz" ]; then
    setfont /usr/share/consolefonts/Uni2-Terminus12x6.psf.gz
elif [ -f "/usr/share/consolefonts/ter-112n.psf.gz" ]; then
    setfont /usr/share/consolefonts/ter-112n.psf.gz
fi

# 重定向控制台输出
echo "Redirecting console to ST7735..."

# 尝试映射控制台到fb1
con2fbmap 1 1 2>/dev/null || true

# 设置环境变量
export FRAMEBUFFER=/dev/fb1

echo "Console redirected to ST7735"

####=========    console-to-st7735.sh  begin =========####



6. 配置系统启动

# 启用服务
systemctl enable st7735-fb.service

# 创建启动脚本
echo "/usr/local/bin/console-to-st7735.sh" >> /etc/rc.local

# 给脚本执行权限
chmod +x /usr/local/bin/console-to-st7735.sh
chmod +x /etc/rc.local



如果修改了，就执行以下：
重新加载 systemd 配置：sudo systemctl daemon-reload
启用服务：sudo systemctl enable st7735-fb.service
启动服务：sudo systemctl start st7735-fb.service